import express from 'express';
import axios from 'axios';
import fs from 'fs';
import path from 'path';
import { program } from 'commander';
import { fileURLToPath } from 'url';
import { AbortController } from 'abort-controller';

const app = express();
app.use(express.json());
app.use(express.urlencoded({ extended: true })); // Add this line
app.use(express.static('public'));

const __dirname = path.dirname(fileURLToPath(import.meta.url));
const CONFIG_PATH = path.join(__dirname, 'targets.json');

program.option('-p, --port <type>', 'Port to serve the proxy')
program.parse(process.argv);

const options = program.opts();
const port = options.port || process.env.port || 3000;

// üß† Load target state
let targets = [];
try {
  if (fs.existsSync(CONFIG_PATH)) {
    targets = JSON.parse(fs.readFileSync(CONFIG_PATH, 'utf8'));
  }
} catch (_) { targets = []; }

const saveTargets = () => {
  fs.writeFileSync(CONFIG_PATH, JSON.stringify(targets, null, 2));
};

// üéØ Request multicaster
const forwardRequest = async (req) => {
  const controllers = [];

  const requests = targets.map((baseURL) => {
    const controller = new AbortController();
    controllers.push(controller);

    const fullUrl = new URL(req.originalUrl, baseURL).toString(); // e.g. /v1

    const forwardHeaders = { ...req.headers };

    // üßº Remove headers that must be generated by axios or would break proxying
    delete forwardHeaders['host'];
    delete forwardHeaders['content-length'];
    delete forwardHeaders['connection']; // optional

    // Force content type explicitly
    forwardHeaders['Content-Type'] = 'application/json';

    return axios({
      url: req.originalUrl,
      method: req.method,
      baseURL,
      data: req.body,
      headers: forwardHeaders,
      signal: controller.signal,
      timeout: 60000,
    })
    .then(res => {
      return res.data
    })
    .catch(err => {
      console.error(`‚ùå Error from ${baseURL}:`, err.message);
      throw err;
    });
  });

  try {
    // Wait for first *successful* response
    const response = await Promise.any(requests);
    
    // Abort other pending requests
    controllers.forEach(ctrl => ctrl.abort());
    
    return response;
  } catch (err) {
    // All failed
    console.error("All flaresolverr targets failed.");
    return null;
  }
};

// üîÅ Proxy everything
app.use('/v1', async (req, res) => {
  // Log thats a connection is comming
  const response = await forwardRequest(req);
  if (response) res.status(200).json(response);
  else res.status(502).json({ error: 'All instances failed' });
});

// üß© API: Get, Add, Delete targets
app.get('/api/targets', (req, res) => res.json(targets));

app.post('/api/targets', (req, res) => {
  const { url } = req.body;
  if (!url || typeof url !== 'string' || targets.includes(url)) {
    return res.status(400).json({ error: 'Invalid or duplicate URL' });
  }
  // if ends up with / remove it
  if (url.endsWith('/')) {
    url = url.slice(0, -1);
  }
  targets.push(url);
  saveTargets();
  res.status(201).json({ success: true });
});

app.delete('/api/targets', (req, res) => {
  const { url } = req.body;
  targets = targets.filter(t => t !== url);
  saveTargets();
  res.json({ success: true });
});

// üîÑ Ping all instances
app.get('/api/ping', async (_, res) => {
  const checks = await Promise.all(targets.map(async (url) => {
    try {
      const now = performance.now();
      const r = await axios.get(`${url}`, { timeout: 4000 });
      const latency = performance.now() - now;
      return { url, status: r.status === 200 ? 'online' : 'offline', latency: Math.round(latency) };
    } catch {
      return { url, status: 'offline', latency: null };
    }
  }));

  // Sort: online first, then by ascending latency
  const sorted = checks.sort((a, b) => {
    if (a.status === 'offline') return 1;
    if (b.status === 'offline') return -1;
    return a.latency - b.latency;
  });

  res.json(sorted);
});

app.listen(port, () => console.log(`üîÅ Flaresolverr Bridge UI + Proxy @ http://localhost:${port}`));
